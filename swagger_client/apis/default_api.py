# coding: utf-8

"""
    Halla I/O

    <p><strong>Getting Started:</strong></p> <ol type=\"1\"> <li><p>Obtain Credentials (Please Contact Halla to Obtain Credentials):</p> <ol type=\"a\"> <li><p><strong>'serviceAccount'</strong>: Add your Service Account in the <strong>header</strong> for all API requests to the Halla services. This is used to track API usage for authorization, billing, etc.</p></li> <li><p><strong>'key'</strong>: Add your API Key to the <strong>query</strong> for all API requests to the Halla services. This is used as a first line of defense to authenticate API requests.</p></li> </ol></li> <li><p>Add Your Catalog:</p> <ol type=\"a\"> <li><p>Use the <strong>POST STORE</strong> route to create a virtual product catalog. Please add a minimum of 1 <strong>thousand products per store</strong>, each with a <strong>'primaryId'</strong> and <strong>'label'</strong>. This will trigger Halla to index the catalog, allowing for Recommendation, Substitution, and Search services within minutes.</p></li> </ol></li> <li><p>Get Recommendations:</p> <ol type=\"a\"> <li><p>Use the <strong>GET PRODUCTS</strong> route and set the strategy to <strong>'recommend'</strong>.</p></li> <li><p>Fill in the <strong>'storeId'</strong> query parameter to use a specific catalog.</p></li> <li><p>Provide <strong>one or more</strong> of the following query parameters:</p> <ol type=\"i\"> <li><p><strong>'productId'</strong>: Biases recommendations to be relevant for a specific product.</p></li> <li><p><strong>'cartProductIds'</strong>: Biases recommendations to be relevant for all products in the cart.</p></li> <li><p><strong>'consumerId'</strong>: Biases recommendations to be relevant for the consumer's previous browsing and past purchase history.</p></li> </ol></li> <li><p>If multiple inputs are given, the recommendations will be blended to best satisfy multiple constraints.</p></li> </ol></li> <li><p>Get Substitutions:</p> <ol type=\"a\"> <li><p>Use the <strong>GET PRODUCTS</strong> route and set the strategy to <strong>'substitute'</strong>.</p></li> <li><p>Fill in the <strong>'storeId'</strong> query parameter to use a specific catalog.</p></li> <li><p>Fill in the <strong>'productId'</strong> query parameter.</p></li> </ol></li> <li><p>Get Search Results:</p> <ol type=\"a\"> <li><p>Use the <strong>GET PRODUCTS</strong> route and set the strategy to <strong>'search'</strong>.</p></li> <li><p>Fill in the <strong>'storeId'</strong> query parameter to use a specific catalog.</p></li> <li><p>Fill in the <strong>'text'</strong> query parameter.</p></li> </ol></li> <li><p>Supercharge Performance with Purchases:</p> <ol type=\"a\"> <li><p>Use the <strong>POST ORDER</strong> route to add one or more transactions to our system. Transactions will be used to fine tune our models to provide a better experience for your shoppers. To enable advanced personalization, please provide the <strong>'consumerId'</strong> field.</p></li> </ol></li> </ol> <p><strong>Advanced Integration:</strong></p> <ul> <li><p>Integrate Multi-Tenant Capabilities:</p> <ul> <li><p>Ensure that store and product <strong>ids</strong> are <strong>globally unique</strong> across all tenants. If needed, tenant name can be appended to the id in question to guarantee uniqueness.</p></li> <li><p>Attach <strong>'brand'</strong> field to allow for better personalization at scale.</p></li> </ul></li> <li><p>Enable Real-Time Inventory:</p> <ul> <li><p>Integrate the <strong>POST STORE</strong> route into your inventory management solution and do one of the following:</p> <ul> <li><p>Call the <strong>POST STORE</strong> route at regular intervals to overwrite existing store data.</p></li> <li><p>Call the <strong>ADD / DELETE</strong> product from store routes to update the catalog upon changes and current availabilities.</p></li> </ul></li> </ul></li> <li><p>(BETA) Enable Advanced Filtering:</p> <ul> <li><p>To enable SNAP, Own-Brand, Sponsored Product and other custom filters, create multiple virtual stores for each real store location. Each virtual store should correspond to a subset of products to include in the filter. Store ids can be generated by prepending the filter identifier to your store id.</p></li> </ul></li> <li><p>(BETA) Run an A/B Test:</p> <ul> <li><p>Work with your Halla Support Rep to define the scope of your A/B test.</p></li> <li><p>Call the <strong>POST ORDER</strong> route to add purchases with which to evaluate.</p></li> <li><p>If you are <strong>tracking spend</strong> between test groups, then it is <strong>required</strong> to attach the <strong>'campaign'</strong> field in the request body of the order.</p></li> <li><p>If you are <strong>testing at the consumer level</strong>, then it is <strong>required</strong> to attach the <strong>'consumerId'</strong> field in the request body of the order.</p></li> </ul></li> <li><p>(BETA) Add Fulfillment Data:</p> <ul> <li><p>Call the <strong>POST ORDER</strong> route multiple times corresponding to when an order is placed and later fulfilled. Set the <strong>'code'</strong> attribute in each item to <strong>'purchased' or 'fulfilled'</strong> corresponding to the order status.</p></li> </ul></li> </ul> 

    OpenAPI spec version: 2.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def add_orders(self, service_account, **kwargs):
        """
        
        Adds new orders, updating associated consumer profiles to allow for real-time personalization.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_orders(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param Orders orders: The orders to create.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_orders_with_http_info(service_account, **kwargs)
        else:
            (data) = self.add_orders_with_http_info(service_account, **kwargs)
            return data

    def add_orders_with_http_info(self, service_account, **kwargs):
        """
        
        Adds new orders, updating associated consumer profiles to allow for real-time personalization.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_orders_with_http_info(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param Orders orders: The orders to create.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'orders']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `add_orders`")

        resource_path = '/v2/orders'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'orders' in params:
            body_params = params['orders']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_products_to_many_stores(self, service_account, **kwargs):
        """
        
        Bulk method to apply product updates across multiple stores. Note: OVERWRITE will remove products with matching product ids in stores not provided in the request.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_products_to_many_stores(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param Updates updates: The updates to apply.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_products_to_many_stores_with_http_info(service_account, **kwargs)
        else:
            (data) = self.add_products_to_many_stores_with_http_info(service_account, **kwargs)
            return data

    def add_products_to_many_stores_with_http_info(self, service_account, **kwargs):
        """
        
        Bulk method to apply product updates across multiple stores. Note: OVERWRITE will remove products with matching product ids in stores not provided in the request.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_products_to_many_stores_with_http_info(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param Updates updates: The updates to apply.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_products_to_many_stores" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `add_products_to_many_stores`")

        resource_path = '/v2/stores/products'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_products_to_store(self, service_account, sid, **kwargs):
        """
        
        Adds one or more products to a store. This method will create a new store if the store id does not exist and will index the newly created products, letting these products be used as input to the Halla services.  Notes:  -Halla will perform best on inventories between 1,000 and 50,000 products.  -Primary product ids persist across multiple stores for a given client.  -Never before seen products will be added in minutes.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_products_to_store(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :param Products products: The products to create.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_products_to_store_with_http_info(service_account, sid, **kwargs)
        else:
            (data) = self.add_products_to_store_with_http_info(service_account, sid, **kwargs)
            return data

    def add_products_to_store_with_http_info(self, service_account, sid, **kwargs):
        """
        
        Adds one or more products to a store. This method will create a new store if the store id does not exist and will index the newly created products, letting these products be used as input to the Halla services.  Notes:  -Halla will perform best on inventories between 1,000 and 50,000 products.  -Primary product ids persist across multiple stores for a given client.  -Never before seen products will be added in minutes.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_products_to_store_with_http_info(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :param Products products: The products to create.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'sid', 'products']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_products_to_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `add_products_to_store`")
        # verify the required parameter 'sid' is set
        if ('sid' not in params) or (params['sid'] is None):
            raise ValueError("Missing the required parameter `sid` when calling `add_products_to_store`")

        resource_path = '/v2/stores/{sid}/products'.replace('{format}', 'json')
        path_params = {}
        if 'sid' in params:
            path_params['sid'] = params['sid']

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'products' in params:
            body_params = params['products']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_store(self, service_account, **kwargs):
        """
        
        Creates / overwrites a store with a distinct catalog. Notes: -Halla will perform best on inventories between 1,000 and 50,000 products. -Primary product ids persist across multiple stores for a given client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_store(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param Store store: The store to create.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_store_with_http_info(service_account, **kwargs)
        else:
            (data) = self.add_store_with_http_info(service_account, **kwargs)
            return data

    def add_store_with_http_info(self, service_account, **kwargs):
        """
        
        Creates / overwrites a store with a distinct catalog. Notes: -Halla will perform best on inventories between 1,000 and 50,000 products. -Primary product ids persist across multiple stores for a given client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_store_with_http_info(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param Store store: The store to create.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'store']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `add_store`")

        resource_path = '/v2/stores'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'store' in params:
            body_params = params['store']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_store(self, service_account, sid, **kwargs):
        """
        
        Deletes store data.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_store(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_store_with_http_info(service_account, sid, **kwargs)
        else:
            (data) = self.delete_store_with_http_info(service_account, sid, **kwargs)
            return data

    def delete_store_with_http_info(self, service_account, sid, **kwargs):
        """
        
        Deletes store data.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_store_with_http_info(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'sid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `delete_store`")
        # verify the required parameter 'sid' is set
        if ('sid' not in params) or (params['sid'] is None):
            raise ValueError("Missing the required parameter `sid` when calling `delete_store`")

        resource_path = '/v2/stores/{sid}'.replace('{format}', 'json')
        path_params = {}
        if 'sid' in params:
            path_params['sid'] = params['sid']

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_products(self, strategy, service_account, **kwargs):
        """
        
        Real-time, contextual product recommendation, substitution and search. Returns a list of products with attached relevance scores.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_products(strategy, service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str strategy: Determines which service should be used for this request. Choose from recommend, substitute, or search. (required)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str text: Text input if search strategy is selected.
        :param str product_id: Subscriber specific product identifier to recommend based on. Required for substitution strategy.
        :param str cart_product_ids: A comma delimited string of subscriber specific product identifiers for a consumer's current cart. If productId is not passed in the query, then recommendations will be based on the cartProductIds. If a productId is passed in the query, then cartProductIds will be used to improve recommendation relevance.
        :param str consumer_id: Subscriber specific consumer identifier to personalize recommendations. If productId and cartProductIds are not passed in the query, then recommendations will be based on previous consumer behavior.
        :param str store_id: Subscriber specific store identifier, selecting the catalog of products to recommend from. If storeId is invalid or is not passed in the query, then recommendations will be sourced from the subscriber's master product list.
        :param int limit: Upper bound on the number of products to return. Default = 15. Max = 30.
        :return: list[ProductRecommendation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_products_with_http_info(strategy, service_account, **kwargs)
        else:
            (data) = self.get_products_with_http_info(strategy, service_account, **kwargs)
            return data

    def get_products_with_http_info(self, strategy, service_account, **kwargs):
        """
        
        Real-time, contextual product recommendation, substitution and search. Returns a list of products with attached relevance scores.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_products_with_http_info(strategy, service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str strategy: Determines which service should be used for this request. Choose from recommend, substitute, or search. (required)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str text: Text input if search strategy is selected.
        :param str product_id: Subscriber specific product identifier to recommend based on. Required for substitution strategy.
        :param str cart_product_ids: A comma delimited string of subscriber specific product identifiers for a consumer's current cart. If productId is not passed in the query, then recommendations will be based on the cartProductIds. If a productId is passed in the query, then cartProductIds will be used to improve recommendation relevance.
        :param str consumer_id: Subscriber specific consumer identifier to personalize recommendations. If productId and cartProductIds are not passed in the query, then recommendations will be based on previous consumer behavior.
        :param str store_id: Subscriber specific store identifier, selecting the catalog of products to recommend from. If storeId is invalid or is not passed in the query, then recommendations will be sourced from the subscriber's master product list.
        :param int limit: Upper bound on the number of products to return. Default = 15. Max = 30.
        :return: list[ProductRecommendation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['strategy', 'service_account', 'text', 'product_id', 'cart_product_ids', 'consumer_id', 'store_id', 'limit']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_products" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'strategy' is set
        if ('strategy' not in params) or (params['strategy'] is None):
            raise ValueError("Missing the required parameter `strategy` when calling `get_products`")
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `get_products`")

        resource_path = '/v2/products'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'strategy' in params:
            query_params['strategy'] = params['strategy']
        if 'text' in params:
            query_params['text'] = params['text']
        if 'product_id' in params:
            query_params['productId'] = params['product_id']
        if 'cart_product_ids' in params:
            query_params['cartProductIds'] = params['cart_product_ids']
        if 'consumer_id' in params:
            query_params['consumerId'] = params['consumer_id']
        if 'store_id' in params:
            query_params['storeId'] = params['store_id']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ProductRecommendation]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_products_from_store(self, service_account, sid, **kwargs):
        """
        
        Gets all products in a store.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_products_from_store(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :return: list[Product]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_products_from_store_with_http_info(service_account, sid, **kwargs)
        else:
            (data) = self.get_products_from_store_with_http_info(service_account, sid, **kwargs)
            return data

    def get_products_from_store_with_http_info(self, service_account, sid, **kwargs):
        """
        
        Gets all products in a store.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_products_from_store_with_http_info(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :return: list[Product]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'sid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_products_from_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `get_products_from_store`")
        # verify the required parameter 'sid' is set
        if ('sid' not in params) or (params['sid'] is None):
            raise ValueError("Missing the required parameter `sid` when calling `get_products_from_store`")

        resource_path = '/v2/stores/{sid}/products'.replace('{format}', 'json')
        path_params = {}
        if 'sid' in params:
            path_params['sid'] = params['sid']

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Product]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_search_terms(self, text, service_account, **kwargs):
        """
        
        Grocery specific autocomplete for search.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_search_terms(text, service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str text: Text to autocomplete. (required)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param int limit: Upper bound on the number of search terms to return. Default = 15. Max = 30.
        :return: list[SearchTerm]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_search_terms_with_http_info(text, service_account, **kwargs)
        else:
            (data) = self.get_search_terms_with_http_info(text, service_account, **kwargs)
            return data

    def get_search_terms_with_http_info(self, text, service_account, **kwargs):
        """
        
        Grocery specific autocomplete for search.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_search_terms_with_http_info(text, service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str text: Text to autocomplete. (required)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param int limit: Upper bound on the number of search terms to return. Default = 15. Max = 30.
        :return: list[SearchTerm]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['text', 'service_account', 'limit']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_terms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'text' is set
        if ('text' not in params) or (params['text'] is None):
            raise ValueError("Missing the required parameter `text` when calling `get_search_terms`")
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `get_search_terms`")

        resource_path = '/v2/searchTerms'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'text' in params:
            query_params['text'] = params['text']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SearchTerm]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_store(self, service_account, sid, **kwargs):
        """
        
        Gets store data.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_store(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :return: list[Product]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_store_with_http_info(service_account, sid, **kwargs)
        else:
            (data) = self.get_store_with_http_info(service_account, sid, **kwargs)
            return data

    def get_store_with_http_info(self, service_account, sid, **kwargs):
        """
        
        Gets store data.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_store_with_http_info(service_account, sid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :return: list[Product]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'sid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `get_store`")
        # verify the required parameter 'sid' is set
        if ('sid' not in params) or (params['sid'] is None):
            raise ValueError("Missing the required parameter `sid` when calling `get_store`")

        resource_path = '/v2/stores/{sid}'.replace('{format}', 'json')
        path_params = {}
        if 'sid' in params:
            path_params['sid'] = params['sid']

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Product]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_store_ids(self, service_account, **kwargs):
        """
        
        Gets all store ids.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_store_ids(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_store_ids_with_http_info(service_account, **kwargs)
        else:
            (data) = self.get_store_ids_with_http_info(service_account, **kwargs)
            return data

    def get_store_ids_with_http_info(self, service_account, **kwargs):
        """
        
        Gets all store ids.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_store_ids_with_http_info(service_account, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_store_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `get_store_ids`")

        resource_path = '/v2/stores'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InlineResponse200',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def remove_product_from_store(self, service_account, sid, pid, **kwargs):
        """
        
        Removes a product from a store.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_product_from_store(service_account, sid, pid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :param str pid: Subscriber specific product id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_product_from_store_with_http_info(service_account, sid, pid, **kwargs)
        else:
            (data) = self.remove_product_from_store_with_http_info(service_account, sid, pid, **kwargs)
            return data

    def remove_product_from_store_with_http_info(self, service_account, sid, pid, **kwargs):
        """
        
        Removes a product from a store.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_product_from_store_with_http_info(service_account, sid, pid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str service_account: Identifies the serviceAccount for authorization purposes. (required)
        :param str sid: Subscriber specific store id (required)
        :param str pid: Subscriber specific product id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account', 'sid', 'pid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_product_from_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params) or (params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `remove_product_from_store`")
        # verify the required parameter 'sid' is set
        if ('sid' not in params) or (params['sid'] is None):
            raise ValueError("Missing the required parameter `sid` when calling `remove_product_from_store`")
        # verify the required parameter 'pid' is set
        if ('pid' not in params) or (params['pid'] is None):
            raise ValueError("Missing the required parameter `pid` when calling `remove_product_from_store`")

        resource_path = '/v2/stores/{sid}/products/{pid}'.replace('{format}', 'json')
        path_params = {}
        if 'sid' in params:
            path_params['sid'] = params['sid']
        if 'pid' in params:
            path_params['pid'] = params['pid']

        query_params = {}

        header_params = {}
        if 'service_account' in params:
            header_params['serviceAccount'] = params['service_account']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))
